<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0-beta1/jquery.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r74/three.js"></script>
    <script type="text/javascript" src="../blotter.js"></script>
  </head>
  <body>
    <div class="canvas-region"></div>

    <canvas class="mouse-position-canvas" width="200" height="200"></canvas>

    <script>
      $(document).ready(function() {


        /**
        *   SET UP BLOTTER.
        *   ------------------------------------------------------
        */

        var mainImageSrc = [
          "void mainImage( out vec4 mainImage, in vec2 fragCoord ) {",

          "   // p = x, y percentage for texel position within total resolution.",
          "   vec2 p = fragCoord / uResolution;",
          "   // d = x, y percentage for texel position within total resolution relative to center point.",
          "   vec2 d = p - uCenterPoint;",

          "   // The dot function returns the dot product of the two",
          "   // input parameters, i.e. the sum of the component-wise",
          "   // products. If x and y are the same the square root of",
          "   // the dot product is equivalent to the length of the vector.",
          "   // Therefore, r = length of vector represented by d (the ",
          "   // distance of the texel from center position).",
          "   // ",
          "   // In order to apply weights here, we add our weight to this distance",
          "   // (pushing it closer to 1 - essentially giving no effect at all) and",
          "   // find the min between our weighted distance and 1.0",
          "   float inverseLenseWeight = 1.0 - uLenseWeight;",
          "   float r = min(sqrt(dot(d, d)) + inverseLenseWeight, 1.0);",

          "   vec2 offsetUV = uCenterPoint + (d * r);",

          "   // RGB shift",
          "   vec2 offset = vec2(0.0);",
          "   if (r < 1.0) {",
          "     float amount = 0.012;",
          "     float angle = 0.45;",
          "     offset = (amount * (1.0 - r)) * vec2(cos(angle), sin(angle));",
          "   }",
          "   vec4 cr = textTexture(offsetUV + offset);",
          "   vec4 cga = textTexture(offsetUV);",
          "   vec4 cb = textTexture(offsetUV - offset);",

          "   vec4 outColor = vec4(0.0);",

          "   if (cr.r > 0.0 || cga.g > 0.0 || cb.b > 0.0) {",
          "     // Adjust rgb values so that colors with transparency appear as if they were atop an opaque white background.",
          "     // (vec4(0.0, 0.0, 0.0, 0.5) _atop white_ is visibly the same as vec4(0.5, 0.5, 0.5, 0.0))",
          "     if (cr.a != 0.0) {",
          "       cr.r = cr.r + cr.a;",
          "     }",
          "     if (cga.a != 0.0) {",
          "       cga.g = cga.g + cga.a;",
          "     }",
          "     if (cb.b != 0.0) {",
          "       cb.b = cb.b + cb.a;",
          "     }",

          "     // Ensure offseted/shifted texels have alpha similar to the texel they are offsetting",
          "     // (this prevents texel from being invisible if cga.a = vec4(0.0, 0.0, 0.0, 0.0)",
          "     cga.a = max(cga.a, max(cr.a, cb.a));",

          "     // Set alpha adjustment value so that white texels keep their transparency.",
          "     float alpha = 1.0 - cga.a;",

          "     // Invert colors (this is cheating but optimal) so that we have CMYK rather than RGB",
          "     // shifted colors and the combination of offsets creates a blacker rather than whiter color.",
          "     outColor = vec4((1.0 - cr.r) - alpha, (1.0 - cga.g) - alpha, (1.0 - cb.b) - alpha, cga.a);",
          "   }",
          "   else {",
          "     outColor = vec4(cr.r, cga.g, cb.b, cga.a);",
          "   }",

          "   mainImage = outColor;",
          "}"
        ].join("\n");


        var texts = ['To', 'communicate', 'Mars', 'converse', 'spirits', 'report', 'the', 'behaviour', 'of', 'sea', 'monster', 'Describe', 'horoscope', 'haruspicate', 'or', 'scry', 'Observe', 'disease', 'in', 'signatures', 'evoke', 'Biography', 'from', 'wrinkles', 'palm', 'And', 'tragedy', 'fingers', 'release', 'omens', 'By', 'sortilege', 'tea', 'leaves', 'riddle', 'inevitable', 'With', 'playing', 'cards', 'fiddle', 'pentagrams', 'Or', 'barbituric', 'acids', 'dissect', 'Sed', 'tincidunt', 'tempor', 'consectetur.', 'Cras', 'imperdiet', 'suscipit', 'massa,', 'ut', 'malesuada', 'enim', 'sollicitudin', 'in.', 'Nullam', 'cursus,', 'lorem', 'vitae', 'cursus', 'gravida,', 'erat'];

        var styleProperties = {
          family: "Charcoal, sans-serif",
          size: 12,
          paddingTop: 12,
          paddingRight: 17,
          paddingBottom: 12,
          paddingLeft: 17,
          leading: 1.5,
          fill: "#0d0f17"
        };

        var blotterTexts = texts.map(function(text) { return new Blotter.Text(text, styleProperties); });

        var mapper = new Blotter.Mapper(blotterTexts);

        var material = new Blotter.MappedMaterial(mapper, mainImageSrc, {
          uniforms : {
            uCenterPoint : { type : "2f", value : [0.5, 0.5] },
            uLenseWeight : { type : "1f", value : 0.9 }
          }
        });

        material.load(function () {
          var renderer = new Blotter.MaterialRenderer(material);
          $(".canvas-region").html(renderer.domElement);
          renderer.start();
        })





        /**
        *   STUFF FOR MOUSE POSITION FOR THIS EXAMPLE.
        *   ------------------------------------------------------
        */

        var mousePositionCanvas = document.getElementsByClassName("mouse-position-canvas")[0],
            ctx = mousePositionCanvas.getContext("2d");

        mousePositionCanvas.style.border = "1px solid black";

        function getMousePos(canvas, e) {
          var rect = canvas.getBoundingClientRect();
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
          };
        }

        mousePositionCanvas.addEventListener('mousemove', function(e) {
          var mousePos = getMousePos(mousePositionCanvas, e),
              nX = mousePos.x / mousePositionCanvas.width,
              nY = 1.0 - (mousePos.y / mousePositionCanvas.height);

          material.updateUniformValueForText(blotterTexts[35], "uCenterPoint", [nX, nY]);
        }, false);
      });
    </script>
  </body>
</html>
